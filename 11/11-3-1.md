# 变量
11.3.1、变量
(1)、定义变量
a、变量名=字面值
自定义变量时候=两边不允许有空格
var=”HelloShell编程”
将一个命令的执行结果赋值给变量：
date=$(date+%F)
将一个变量赋值给另一个变量：
A=$B
例：
myvar=”呜呜呜”
echo${myvar}
b、declare
格式：
declare[选项]变量名[=字面值]变量名[=字面值];
选项：
-r定义只读变量，等价于readonly变量：
declare-rvar1
-i整数：
declare-inumber
#脚本余下的部分会把"number"当作整数看待。
-a数组：
declare-aindices
-f函数：
declare-f
	如果在脚本中使用declare-f,而不加任何参数的话,那么将会列出这个脚本之前定义的所有函数(包括函数体的内容)。如果在脚本中使用declare-ffunction_name这种形式的话,将只会列出这个函数。
-x导出变量成环境变量：
declare–x
例：
declare–ia=20b=30
c、local变量
#!/bin/sh

a()
{
locals=1
echo$s
}

b()
{
s=2
echo$s
}

s=0
a
echo$s
b
echo$s
输出结果：
[work]#./test.sh
1
0
2
2
d、常量或只读变量
readonlyA=3
(2)、变量命名规则
组成：
字母，数字，下划线
特别注意：
只能字母，下划线作为开头字符变量；
变量名一般使用大写
严格区分大小写
歧义字面值：
当字面值产生歧义，使用””或者’’界定
“”与‘’有区别
(3)、使用变量
${变量}
echo${a}${b}
$变量
在不产生歧义的情况下使用：
echo$a$b
(4)、导出变量
临时变量（环境变量）：
export变量
导出的变量只在当前Shell和子Shell中有效：
delcare–x
(5)、文件名替换-通配符
	在变量值中有一些特殊的替换字符。这些字符在运行的时候会被替换成他表示的真正的值。
	文件名替换，只能使用在表示文件操作的指令之中。
*		通配任意字符长度的文件
?		通配文件一个字符
[]		通配文件中指定范围内的字符
-		在[]中使用表示范围
^		在[]中使用表示否定
(6)、变量替换
变量为空或者没有定义，则使用Value替换变量，但Parameter变量不改变：
${变量:-值Value}
Parameter为空或者没有定义，则使用word替换parameter，Parameter变量的值改变为word：
${parameter:=word}
Parameter为空或者没有定义，则显示message到错误输出：
${parameter:?message}
Parameter有值或者已经定义，则使用word替换，但Parameter变量不改变：
${parameter:+word}
(7)、命令替换
	使用``做为界定符号，会把``中的字符做为命令执行，并把执行结果做为变量替换。也可以使用$(命令)
例：
`date+%d`
(8)、结构替换
a、在shell中还有一个比较特殊的表达式替换：
$((表达式))
注意((后与))前的空格
结构替换中表达式支持的运算符号有：
算术运算:		+-*/%**++--
关系运算:		<<=>>===!=
逻辑运算:		&&||!~
位运算:		&|^
复合运算:		+=-=*=/=%==&=|=^=
三目运算:		expr?expr1:expr2
其他()	：	expr,expr
其中不支持小数运算。
b、表达式中支持变量的使用。

例：
a=10
b=20
c=$((a+b))
(9)、转义字符
	在Shell中有些字符容易产生歧义，需要做特殊处理，这就是转义。
	Shell中处理转义的字符有三个：
\对字符特殊转义
‘‘对字符串转义
“”对字符串转义
$’’
需要使用\转义的元字符：
*?[]‘“\$;&()|^<>换行空格制表符
如果\后面没有元字符，则被\忽略。
(10)、列出变量
set
当你执行程序时的参数数目超过9个时，可以使用shift命令将参数往前移一格，如此即可使用第10个以后的参数。除此之外，还可以用set命令改变$n及$*，方法如下：
setstring
如此$*的值即为string，而分解后则会放入$n。如果set命令后面没有参数，则会列出所有已经设定的变量以及其值。
(10)、删除变量
unset：
删除变量或函数。
格式：
unset变量名
(11)、环境变量
a、本地变量(临时变量)
	本地变量也叫临时变量，是Shell程序内部定义的，其使用范围仅限于当前的程序，对其它程序不可见。包括用户自定义变量和位置变量。
b、环境变量
	是永久变量，不随Shell脚本的执行的结束而消失。
#echo$shell
#echo${shell}
#echo$shell//显示环境变量
	env显示当前用户的环境变量。
	在shell中环境变量很多，一种是系统与用户级别的环境变量，一种是SHELL级别环境变量。使用env查看系统用户环境变量，我们需要理解的是PATH与LD_LIBRARY_PATH两个的作用。使用set查看SHELL相关环境变量。
常见SHELL环境变量：
PATH环境变量					：执行文件搜索路径。路径使用:分隔。
PS1与PS2环境变量			：提示符号。
LINENO环境变量				：SHELL脚本的代码行数。
BASH_VERSINFO环境变量		：SHELL的版本信息，是数组。
BASH_VERSION环境变量		：SHELL的版本。
GROUPS环境变量				：用户所在的组。
HOSTNAME环境变量			：主机名。
OLDPWD环境变量				：老工作目录。
OSTYPE环境变量				：操作系统类型。
PWD环境变量					：当前工作路径。
SECONDS环境变量				：SHELL执行的秒数。
SHLVL环境变量				：SHELL的层数。
HOME环境变量					：用户主目录。
SHELL环境变量				：登录SHELL类型。
PROMPT_COMMAND环境变量	：指令执行完毕后的提示指令。
MACHTYPE环境变量			：机器类型。
(12)、特殊变量与命令行参数
有些变量是一开始执行Script时就会设定，且不能被修改，但我们不叫它只读的系统变量，而叫它特殊变量。这些变量当一执行程序时就有了，用户无法将一般的系统变量设定成只读的。以下是一些等殊变量：
$*这个程序的所有参数
$#这个程序的参数个数
$$这个程序的PID
$!执行上一个后台指令的PID
$?执行上一个指令的返回值
SHELL中特殊变量如下：
$*	：	所有的位置参数，从1开始。
$@	：	位置参数，是传给脚本的所有参数的列表，所有空格分开的命令行参数。		从1开始。当在双引号里展开时，每个参数展开成独立的词。比如：$1			表示第一个参数。
$#	：	是命令行传给脚本的位置参数个数。
$?	：	上一个程序运行的返回值。0或1。
$$	：	shell的进程ID。
$!	：	展开成最近在后台（异步）执行的命令的进程ID。
$0	：	展开成shell或者shell脚本名，是脚本本身的名字。
$1：	是传递给该shell脚本的第一个参数。
$2：	是传递给该shell脚本的第二个参数。
$*：	是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数			可超过9个。
$$：	是脚本运行的当前进程ID号。
$?：	是显示最后命令的退出状态，0表示没有错误，其他表示有错误。
	Shell解释执行用户命令时，将命令行的第一个部分作为命令名，其它部分作为参数。由出现在命令行上的位置确定的参数称为位置参数
$1…$9表示命令行参数或者函数参数
例：
ls–lfile1file2file3
$0这个程序的文件名ls-l
$n这个程序的第n个参数值，n=1-9
例：
#!/bin/sh
echo"number:$#"
echo"scname:$0"
echo"first:$1"
echo"second:$2"
echo"arguments:$@"
echo"showparmlist:$*"
echo"showprocessid:$$"
echo"showprecommstat:$?"
执行脚本：
#./variableaabb
number:2
scname:./variable
first:aa
second:bb
argume:aabb
showparmlist:aabb
showprocessid:24544
showprecommstat:0
(13)、选项解析
getopts选项变量
选项表示以－开头的参数，存放选项的变量。
选项不匹配，则存放一个问号到变量，并返回0，并输出一个标准错误。
选项匹配，则存放选项到变量，并返回0。
没有选项，或者没有－开头的参数，则返回非0。
(14)、数组变量
定义数组：
语法一：
ARRAY[INDEX]=value
说明：INDEXNR需要使用一个值为正数的数学表达式。
语法二：
declare-aARRAYNAME
说明：一个带有索引值的声明也是可以接受的，但是索引值将被忽略。
语法三：
ARRAY=(value1value2...valueN)

使用数组：
语法：
数组名[索引]
说明：
*，@指向所有的数组内容。
不指定下标，则得到数组第一个元素。
下标从0开始。

删除数组与删除变量一样：
unset数组名
示例：
#!/bin/bash
arr[1]=20
arr[2]=30
declare-aarr1=(112233)
echo${arr[1]}
echo${arr1[@]}
echo${arr1[1]}
作业：
输入10个数字，并倒序输出
1，2，3-10
10，9，8-1
arr[$i]
(15)、提示符变量
	Bash使用4个提示符字符串，它们保存在PS1，PS2，PS3，PS4里。PS提示符号分多级，比如PS1,PS2,PS3。
例子：
PS1="\u@\h:\w>"
PS1="\u@\w:\[hello\]"
PS1为基本提示符字符串，即通常的shell提示符，默认取值为“\s-\v\$”。
PS2为二级提示符字符串，默认取值为>。
PS3和PS4与shell编程调试有关。
可用的提示符定制：
命令含义：
ASCII响铃字符（007）：
\a
“星期月天”格式日期
\d
ASCII转义字符（003）
\e
主机名
\H
主机名加.
\h
回车和换行
\n
shell名字
\s
12小时HH:MM:SS格式当前时间
\T
HH:MM:SS格式当前日期
\t
12小时am/pm格式当前日期
\@
当前用户的用户名
\u
Bash版本
\v
Bash发布版本；版本和补丁
\V
当前工作目录
\w
当前工作目录的基名
\W
当前命令编号
\#
当前命令的历史编号
\!
如果有效UID为0，则打印#，否则打印$
\$
打印一个反斜线：
\\
开始非打印字符的序列，如终端控制序列：
\[
结束非打印字符序列：
\]
八进制字符编码：
\nnn
