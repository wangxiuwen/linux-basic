# init


(1)、什么是init
	init是linux系统操作中不可缺少的程序之一。是一个由内核启动的用户级进程。
	内核启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式来启动其他用户级的进程或服务。所以,init是所有进程的祖先，它的进程号(PID)始终为1，所以发送TERM信号给init会终止所有的用户进程、守护进程等。shutdown就是使用这种机制。(TERM信号将终止所有不能捕获该信号的进程。至于那些可以捕获该信号的进程可能就需要使用kill（9）信号了，该信号是不能被捕捉的。)
	内核会在过去曾使用过init的几个地方查找它，它的正确位置（对Linux系统来说）是/sbin/init。如果内核找不到init，它就会试着运行/bin/sh，如果运行失败，系统的启动也会失败。
	init定义了8个运行级别(runlevel)，init0为关机，init1不是reboot，而是单用户，init6才是重启。
	另外，还有telinit命令可以改变init的运行级别，比如，telinit-iS可使系统进入单用户模式，并且得不到使用shutdown时的信息和等待时间。
(2)、运行级别
a、runlevel：
	运行级就是操作系统当前正在运行的功能级别。这个级别从1到6，具有不同的功能。其功能级别如下：
#0-停机（千万不能把initdefault设置为0）
#1-单用户模式
#2-多用户，没有NFS
#3-完全多用户模式(标准的运行级)
#4-没有用到
#5-X11（xwindow)
#6-重新启动（千万不要把initdefault设置为6——把被你黑掉的linux的initdefault设置为0或6也算是拒绝服务攻击噢！）
运行级别S：单用户（恢复）模式，文本登录界面，只运行很少几项系统服务。

警告：不要直接将运行级别修改为运行级别S。
	使用telinit要求系统切换为运行级别1，这会让系统首先进入运行级别1，此时适当的系统进程（运行系统服务）将被杀死，然后自动进入运行级别S。直接将运行级别修改为运行级别S，可以让系统进入运行级别S，而不会首先杀死任何进程。因此，通常最好不要这样做。
	只有当系统引导的时候，Upstartinit守护进程才会去查看文件/etc/inittab。此时前一个运行级别并没有遗留任何正在运行的进程，因此直接进入运行级别S不会有任何问题。

	除此之外还有ABC三个运行级别，但在RHLinux中都没有意义。
	这些级别在/etc/inittab文件里指定。
	这个文件是init程序寻找的主要文件，最先运行的服务是放在/etc/rc.d目录下的文件。在大多数的Linux发行版本中，启动脚本都是位于/etc/rc.d/init.d中的。这些脚本被用ln命令连接到/etc/rc.d/rcn.d目录。(这里的n就是运行级0-6)，例如，init0执行的脚本为/etc/rc.d/rc0.d。
b、运行级别的配置：
各字段的解释：
运行级别的配置是在/etc/inittab行内进行的，如下所示：
12:2:wait:/etc/init.d/rc2
各字段解释如下：
label:runlevels:action:process
label：
	1、label是一个任意指定的四个字符以内的序列标号，用来标示输入的值。该标签在本文件内必须唯一。一些系统只支持2个字符的标签。鉴于此原因，多数人都将标签字符的个数限制在2个以内。Sysvinit系统限制为2字符。但实际上，某些特定的标签是常用的，在RedHatLinux中使用的标签是：
标签	含义
id	用来定义缺省的init运行的级别。
si	是系统初始化的进程。
ln	其中的n从1~6,指明该进程可以使用的runlevel的级别。
ud	是升级进程。
ca	指明当按下Ctrl+Alt+Del时运行的进程。
pf	指当UPS表明断电时运行的进程。
pr	是在系统真正关闭之前，UPS发出电源恢复的信号时需要运行的进程。
x	是将系统转入X终端时需要运行的进程。
注意：
	像getty之类的登陆进程必须使id字段与tty编号一致，如tty1需要id=1，许多老版本的登陆进程都遵循这种规则。
runlevels：
	runlevel字段指定runlevel的级别。可以指定多个runlevel级别，也可以不为runlevel字段指定特定的值。(另外sysinit、boot、bootwait这三个进程会忽略这个设置值。这里是2，可以有多个，表示在相应的运行级均需要运行。
action：
	表示进入对应的runlevels时，init应该运行process字段的命令的方式，常用的字段值及解释如下：
字段	解释
respawn	表示init应该监视这个进程，即使其结束后也应该被重新启动。
wait	init应该运行这个进程一次，并等待其结束后再进行下一步操作。
once	init需要运行这个进程一次。
boot	随系统启动运行，所以runlevel值对其无效。
bootwait	随系统启动运行，并且init应该等待其结束。
off	没有任何意义。
initdefault	系统启动后的默认运行级别；由于进入相应的运行级别会激活对应级别的进程，所以对其指定process字段没有任何意义。如果inittab文件内不存在这一条记录，系统启动时在控制台上询问进入的运行级。
sysinit	系统启动时准备运行的命令。比如说，这个命令将清除/tmp。可以查看/etc/rc.d/rc.sysinit脚本了解其运行了那些操作。
powerwait	允许init在电源被切断时，关闭系统。当然前提是有UPS和监视UPS并通知init电源已被切断的软件。RHlinux默认没有列出该选项。
powerfail	同powerwait，但init不会等待正在运行的进程结束。RHlinux默认没有列出该选项。
powerokwait	当电源监视软件报告“电源恢复”时，init要执行的操作。
powerfailnow	检测到ups电源即将耗尽时，init要执行的操作，和powerwait/powerfail不同的哟。
ctrlaltdel	允许init在用户于控制台键盘上按下Ctrl+Alt+Del组合键时，重新启动系统。注意，如果该系统放在一个公共场所，系统管理员可将Ctrl+Alt+Del组合键配置为别的行为，比如忽略等。
kbrequest	监视到特定的键盘组合键被按下时采取的动作，现在还不完善。
ondemand	一个进程标记成ondemand运行级别，不论ondemand运行级别是否被调用都将会被执行。因此，不会有运行级别的改变发生(ondemand运行级别是‘a’,‘b’,和‘c’)。

process：
	process字段包含init执行的进程，该进程采用的格式与在命令行下运行该进程的格式一样，因此process字段都以该进程的名字开头，紧跟着是运行时，紧跟着是运行时要传递给该进程的参数。比如/sbin/shutdown-t3-rnow，该进程在按下Ctrl+Alt+Del时执行，在命令行下也可以直接输入来重新启动系统。
	当运行级别改变，并且正在运行的程序并没有在新的运行级别中指定需要运行，那么init会先发送一个SIGTERM信号终止，然后是SIGKILL。
	一句话，process就是具体应该执行的命令。
(3)、补充
a、补充1：
1、关于进入单用户模式，一般都是采用设置initdefault为1或者在grub/lilo中指定一个“single”或“emergency”命令行参数来实现。其实另外还有一个更干净的方法，编辑：
kernel/vmlinuz-2.6.9-22.ELroroot=/bin/sh
这样init就直接启动一个shell，其他任何进程都没有启动哦，够干净吧！
2、你可以自己制定启动时所进入的runlevel，如果你的系统使用的是lilo，在启动命令中将相应的部分为：
LILO:linux5
如果你使用的是GRUB，在启动时你可以按住e键进入设置模式，相应的位置显示为：
kernel/vmlinuzroroot=/dev/hda15
3、系统正在运行时，telinit(或init)命令可更改运行级别。
切换运行模式使用telinit命令(root用户)：
$/sbin/telinit
通常，切换运行模式的目的是重启某些应用进程，比如XFree86，将运行模式从5切换到3将终止XFree86以及与之相关的所有进程，然后再把运行模式切换到5，XFree86就可以很干净的启动。在做这些工作之前，请确保所有在XFree86下的工作都已经保存，用root用户：
$/sbin/telinit3
$/sbin/telinit5
在键入命令之后，你的屏幕可能会显示一些服务启动或者停止的信息。
b、补充2：
在单用户模式下引导：
	一个重要的运行级别就是单用户模式（运行级别1），该模式中，只有一个系统管理员使用特定的机器，而且尽可能少地运行系统服务，其中包含登录。单用户模式对少数管理任务（比如在/usr分区上运行fsck）而言，是很有必要的，因为这需要卸载分区，但这是不可能的，除非所有的服务系统已被杀死。
一个正在运行的系统可以进入单用户模式，具体做法是利用init，请求运行级别1。内核启动时，在内核命令行指定single或emergency关键字，就可进入运行级别1了。内核同时也为init指定命令行，init从关键字得知自己不应该采用默认的运行级别（内核命令行的输入方式和你启动系统的方式有关）。有时，以单用户模式进行启动是必要的，这样一来，用户在装入分区之前，或至少在装入分散的/usr分区之前，能手工运行fsck（在分散的文件系统上，任何活动都可能使其更为分散，所以应该尽可能地运行fsck）。
	如果自动化的fsck在启动时失败了，启动脚本init的运行将自动进入单用户模式。这样做是为了防止系统使用不连贯的文件系统，这个文件系统是fsck不能自动修复的。文件系统不连贯的现象极为少见，而且通常会导致硬盘的不连贯或实验性的内核释放，但最好能做到防患于未然。
	由于安全上的考虑，在单用户模式下，启动外壳脚本之前，配置得当的系统会要求用户提供root密码。否则，它会简单地为LILO输入合适的一行代码，以root的身份登录（当然，如果/etc/passwd已经由于文件系统的问题而不连贯了，就不适合这里的原则了，为对付这种情况，你最好随时准备一张启动盘）。
不同的运行级有不同的用处，也应该根据自己的不同情形来设置。例如，如果丢失了root口令，那么可以让机器启动进入单用户状态。在启动后的lilo提示符下输入：
init=/bin/shrw
使机器进入运行级1，并把root文件系统挂为读写。他会跳过所有系统认证，让你可以使用passwd程序来改变root口令，然后启动到一个新的运行级。
(4)、telinit
	具有root特权身份的用户可以使用实用工具telinit来关闭系统、重启系统，或者在恢复（单用户）模式与多用户模式之间切换。实用工具telinit属于一种迁移工具，用来兼容SysVinit系统。在运行Upstart的系统中，这个实用工具会根据自己的参数发送某个运行级别事件。telinit命令的格式如下：
telinitrunlevel
其中runlevel为表1-1所述虚拟运行级别之一。
